This tutorial assumes at least a basic working knowledge of HTML and Javascript.  

First, let's get some basic page stuff out of the way.  Start your HTML page and import all the Javascript files:

<html>
<head>
  <title>C64Style Tutorial - Alien Invasion</title>
  <script type="text/javascript" src="../lib/Common/Utils.js"></script>
  <script type="text/javascript" src="../lib/Common/PriorityQueue.js"></script>
  <script type="text/javascript" src="../lib/Common/UniquePriorityQueue.js"></script>
  <script type="text/javascript" src="../lib/Common/Queue.js"></script>
  <script type="text/javascript" src="../lib/Color.js"></script>
  <script type="text/javascript" src="../lib/ColorPointer.js"></script>
  <script type="text/javascript" src="../lib/Constants.js"></script>
  <script type="text/javascript" src="../lib/EventType.js"></script>
  <script type="text/javascript" src="../lib/Event.js"></script>
  <script type="text/javascript" src="../lib/Screen.js"></script>
  <script type="text/javascript" src="../lib/PixPathTypes.js"></script>
  <script type="text/javascript" src="../lib/CharacterMap.js"></script>
  <script type="text/javascript" src="../lib/CharacterRenderer.js"></script>
  <script type="text/javascript" src="../lib/Layer.js"></script>
  <script type="text/javascript" src="../lib/TextPrompt.js"></script>
  <script type="text/javascript" src="../lib/TextLayer.js"></script>
  <script type="text/javascript" src="../lib/MoveOrder.js"></script>
  <script type="text/javascript" src="../lib/GfxElementZIndexComparable.js"></script>
  <script type="text/javascript" src="../lib/GfxElement.js"></script>
  <script type="text/javascript" src="../lib/PixRenderer.js"></script>
  <script type="text/javascript" src="../lib/PixElement.js"></script>
  <script type="text/javascript" src="../lib/Sprite.js"></script>
  <script type="text/javascript" src="../lib/PixSprite.js"></script>
  <script type="text/javascript" src="../lib/GfxLayer.js"></script>
</head>

You can also include any css files in the head if you want special page styling.
Setup the page body:

<body>
  <h1>Tutorial - Alien Invasion</h1>
  <div id="content"></div>
</body>

The "content" div will hold our C64 screen.

So now, let's create a bare-bones screen:

<script>
var GameContext = GameContext || {};

var config = {
  "rows" : 25,
  "cols" : 40,
  "scaleX" : 2,
  "scaleY" : 2
};

function initialize(targetDiv, config) {
  GameContext.screen = new C64Style.Screen(targetDiv, config);
  GameContext.screen.initialize();
  GameContext.screen.render();
}

initialize(document.getElementById("content"), config);
</script>

And be sure to close your HTML tag.
</html>

If you save your html file and open it in the browser, it should look something like this:

<IMAGE1>

Pretty basic.
Let's change the colors a bit on the screen.  We can add this to the config variable:

var config = {
  "rows" : 25,
  "cols" : 40,
  "scaleX" : 2,
  "scaleY" : 2,
  "backgroundColor" : C64Style.Color.BLACK,
  "borderColor" : C64Style.Color.DARKGREY
};

You now have:

<IMAGE2>

Let's create a text layer and write to the screen.  You'll notice in the example above, we've created a GameContext variable in the global scope.  
That is going to store all the variables and things that we create, so that we have easy access to them from anywhere (you could just put all the variables in the global scope, but this is a little cleaner).  You can already see that we create a 'screen' property, that is a reference to our C64 Screen.


We'll do the same thing to add a text layer:

function initialize(targetDiv, config) {
  GameContext.screen = new C64Style.Screen(targetDiv, config);
  GameContext.screen.initialize();

  GameContext.textLayer = GameContext.screen.createLayer("TextLayer");
  GameContext.textLayer.writeText("Alien Invasion!", 12,1, C64Style.Color.WHITE);

  GameContext.screen.render();
}

This gives you:

<IMAGE3>

Not much going on so far.  Let's make things interesting by creating a space ship.  We'll use an ImageElement for this, and load up a png.
We need to adjust a couple of things to accommodate the time it takes to load an image - we want to ensure that the image has finished loading before we start rendering the screen.

At the bottom of your script, replace this:
initialize(document.getElementById("content"), config);
with this:

GameContext.shipPng = new Image();
GameContext.shipPng.src = "ship.png";
GameContext.shipPng.onload = function() {
	initialize(document.getElementById("content"), config);
}
This way, our initialization code is only called when the image is done.
So we have our image loaded now, but we need a way to put it on our screen.


Below the code that creates the text layer, let's add a graphics layer:

  GameContext.textLayer = GameContext.screen.createLayer("TextLayer");
  GameContext.textLayer.writeText("Alien Invasion!", 12,1, C64Style.Color.WHITE);

  GameContext.gfxLayer = GameContext.screen.createLayer("GfxLayer");
  
Now it's time to create the element for the ship:

  GameContext.shipElement = new C64Style.ImageElement(GameContext.screen, GameContext.gfxLayer, {
    image: GameContext.shipPng,
    sourceX:0,
    sourceY:0,
    sourceWidth:32,
    sourceHeight:32,
    width:32,
    height:32,
    x:144,
    y:160
  });

Then add the element to your graphics layer:

  GameContext.gfxLayer.addElement(GameContext.shipElement);

Your initialize function should look like this:

function initialize(targetDiv, config) {
  GameContext.screen = new C64Style.Screen(targetDiv, config);
  GameContext.screen.initialize();

  GameContext.textLayer = GameContext.screen.createLayer("TextLayer");
  GameContext.textLayer.writeText("Alien Invasion!", 12,1, C64Style.Color.WHITE);

  GameContext.gfxLayer = GameContext.screen.createLayer("GfxLayer");

  GameContext.shipElement = new C64Style.ImageElement(GameContext.screen, GameContext.gfxLayer, {
    image: GameContext.shipPng,
    sourceX:0,
    sourceY:0,
    sourceWidth:32,
    sourceHeight:32,
    width:32,
    height:32,
    x:144,
    y:160
  });

  GameContext.gfxLayer.addElement(GameContext.shipElement);

  GameContext.screen.render();
}

And your page should look like this:

<IMAGE4>
  
Things are getting exciting!

Let's add some aliens.
Instead of using an image, let's create aliens using pix arrays.  This will let us use multiple palettes.
We will use two sets of pix arrays and create a sprite.
The code for the arrays is kind of long and uninteresting.  We'll load it from separate files.
Add these two lines to your <head> section:

  <script type="text/javascript" src="alienPix1.js"></script>
  <script type="text/javascript" src="alienPix2.js"></script> 
  
These will load alienPix1 and alienPix2 into our GameContext.

We want a bunch of aliens, so let's make an array for them after the code that adds the ship element:

  GameContext.aliens = [];

Set up our sprite frames:
   GameContext.alienFrame1 = new C64Style.PixSpriteFrame({pixArray:GameContext.alienPix1, duration:200});
  GameContext.alienFrame2 = new C64Style.PixSpriteFrame({pixArray:GameContext.alienPix2, duration:200});
  
  These reference the alienPix arrays we imported. duration tells us how long (milliseconds) to display each frame.
  
  Now let's use a loop to create the sprites and position them on the screen:
  
  var x = 8;
  for (var i = 0; i < 8; i++) {
    var newAlien = new C64Style.PixSprite(GameContext.screen, GameContext.gfxLayer, {
      frames:[GameContext.alienFrame1,GameContext.alienFrame2],
      x:x,
      y:32,
      defaultPalette: C64Style.Color.getDefaultPalette()
    });
    GameContext.aliens.push(newAlien);
    GameContext.gfxLayer.addElement(newAlien);
    x += 20;
  }
  
 There is a lot going on there!  Notice that we are creating an array of frames using the frames we setup in the previous step.  
 We are pulling in the default palette provided by the C64Style.Color enum.
 Also notice we advance the x position each time we create and alien, and that we add the alien to both the GameContext.aliens array and to the gfxLayer.
 
 If all went well, your screen ought to look like this:
 
 <IMAGE5>
 
 This is a static image; what you should see is some animated aliens.
 
 Let's add another row of aliens.  We can do the same thing, but let's use a different palette.
 
   var altPalette = [
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.YELLOW,
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.RED,
    C64Style.Color.LIGHTGREEN
  ];
  
  In the PixArray, we only use colors 2, 6, and 7 from the default palette.  With our new palette, we change the colors at those indices, and set the rest to black (no special
  reason to do this, just to make it more apparent those color indices aren't used.)  
 We're doing basically the same thing again, but with a different palette.  Let's extract what we did before into a function:
 
 function createAlien(x,y, palette) {
  var newAlien = new C64Style.PixSprite(GameContext.screen, GameContext.gfxLayer, {
    frames:[GameContext.alienFrame1,GameContext.alienFrame2],
    x:x,
    y:y,
    defaultPalette: palette
  });
  return newAlien;
}

Then we can update the code we did before to look like this:
  var x = 8;
  for (var i = 0; i < 8; i++) {
    var newAlien = createAlien(x, 32, C64Style.Color.getDefaultPalette());
    GameContext.aliens.push(newAlien);
    GameContext.gfxLayer.addElement(newAlien);
    x += 20;
  }
 
 
and we can just copy and paste that bit, reset our x variable, bump the y position a little bit, and plugin the new palette:
 
  var altPalette = [
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.YELLOW,
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.RED,
    C64Style.Color.LIGHTGREEN
  ];

  x = 8;
  for (var i = 0; i < 8; i++) {
    var newAlien = createAlien(x, 48, altPalette);
    GameContext.aliens.push(newAlien);
    GameContext.gfxLayer.addElement(newAlien);
    x += 20;
  }
 
 
 Now you should have this:
 
 <IMAGE6>
 
 And your initialize function should look like this:
 function initialize(targetDiv, config) {
  GameContext.screen = new C64Style.Screen(targetDiv, config);
  GameContext.screen.initialize();

  GameContext.textLayer = GameContext.screen.createLayer("TextLayer");
  GameContext.textLayer.writeText("Alien Invasion!", 12,1, C64Style.Color.WHITE);

  GameContext.gfxLayer = GameContext.screen.createLayer("GfxLayer");

  GameContext.shipElement = new C64Style.ImageElement(GameContext.screen, GameContext.gfxLayer, {
    image: GameContext.shipPng,
    sourceX:0,
    sourceY:0,
    sourceWidth:32,
    sourceHeight:32,
    width:32,
    height:32,
    x:144,
    y:160
  });

  GameContext.gfxLayer.addElement(GameContext.shipElement);

  GameContext.aliens = [];
  GameContext.alienFrame1 = new C64Style.PixSpriteFrame({pixArray:GameContext.alienPix1, duration:200});
  GameContext.alienFrame2 = new C64Style.PixSpriteFrame({pixArray:GameContext.alienPix2, duration:200});
  var x = 8;
  for (var i = 0; i < 8; i++) {
    var newAlien = createAlien(x, 32, C64Style.Color.getDefaultPalette());
    GameContext.aliens.push(newAlien);
    GameContext.gfxLayer.addElement(newAlien);
    x += 20;
  }

  var altPalette = [
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.YELLOW,
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.BLACK,
    C64Style.Color.RED,
    C64Style.Color.LIGHTGREEN
  ];

  x = 8;
  for (var i = 0; i < 8; i++) {
    var newAlien = createAlien(x, 48, altPalette);
    GameContext.aliens.push(newAlien);
    GameContext.gfxLayer.addElement(newAlien);
    x += 20;
  }

  GameContext.screen.render();
}
 
 So now we have some cool retro looking graphics.
But it isn't a game just yet.  

Let's make our ship move.  C64Style offers a couple of ways to handle moving elements.  In this case, we want to tie the movement of the ship to the arrow keys, 
left and right, and keep the ship in the bounds of the screen.  To do this, we are going to add a couple of event handlers.  We want to know when the user 
pushes a key down, and lets a key up; when the key is down, we want to be moving the ship, and when they let the key up, we want to cease moving the ship.
If the key that was pressed isn't one we are using, we want it to have normal behavior for that key. So we add to our ever growing initialize function:

  document.onkeydown = function(e) {
    var preventDefault = false;
    switch (e.key) {
      case "ArrowLeft":
        GameContext.shipMovingLeft = true;
        break;
      case "ArrowRight":
        GameContext.shipMovingRight = true;
        break;
      default:
        break;
    }
    if (preventDefault) event.preventDefault();
    return !preventDefault;
  }
  document.onkeyup = function(e) {
    var preventDefault = false;
    switch (e.key) {
      case "ArrowLeft":
        GameContext.shipMovingLeft = false;
        break;
      case "ArrowRight":
        GameContext.shipMovingRight = false;
        break;
      default:
        break;
    }
    if (preventDefault) event.preventDefault();
    return !preventDefault;
  }

  So, if the left key is pressed, we set a variable shipMovingLeft to true, and likewise for the right key.  If one of those keys is let up we set the ship moving variable to false.
  
  That's great, but we still need to move the ship.  Let's create a function to do that, outside of the initialize function..
  
GameContext.shipMoveRate = 1/8;
function updateShip(event) {
  var ship = GameContext.shipElement;
  if (GameContext.shipMovingLeft && ship.getX() > 4) {
    ship.setX(ship.getX() - event.data.diff * GameContext.shipMoveRate);
  }
  if (GameContext.shipMovingRight && ship.getX() < 284) {
    ship.setX(ship.getX() + event.data.diff * GameContext.shipMoveRate);
  }
}
	
	For shorthand, this function assigns the GameContext.shipElement to a local variable.
	I also set a variable called shipMoveRate, this will make it easier if we want to change it later.
	So here you can see, if the ship is moving left, we will subtract the time difference (relative to the previous render cycle, more on this in a minute) multiplied by the shipMoveRate
	from the current X location; if it is less than some (arbitrary) boundary (4) we keep it at that boundary.  We do something analogous for if the ship is moving right.
	About the time difference: in general the browser will try to run the canvas at 60 frames per second; so when rendering we will find that the difference between the previous
	render cycle and the current one is usually 15-16ms.  However, this may change if the last render cycle took to long, or if for some reason the browser thread was kept 
	suspended longer. So, by factoring in the time difference, we can create smooth movement, even if there are small hiccups in the rate the browser updates the canvas.
	
	We get the time diff from an event that is passed into the function.
	So, In order for this to work, we need to call this function from an event hook, specifically BEFORE_RENDER in the screen.	We can add this in the initialize function after our key event handlers.
	
  GameContext.screen.on(C64Style.EventType.BEFORE_RENDER, function(e) {
    updateShip(e);
  });
	
  This calls the function before each render cycle, and passes a BEFORE_RENDER event.  
  Now that our ship can move, we need to work on our aliens.  Orchestrating the aliens' movement is a little more complex.
  In 'invaders' tradition, we want our aliens to move left or right, and to move down a little bit when they hit the edge of the screen.
  Let's start by creating a function to set our aliens in motion:
  
  function setAliensMoving() {
	  GameContext.aliens.forEach(function(alien) {
		if (GameContext.alienMoveDirection === "RIGHT") {
		  alien.setMoveRates(48,0);
		} else {
		  alien.setMoveRates(-48,0);
		}
	  });
	}

	This will give each of our aliens a movement rate, depending on the move direction.  We haven't set the move direction anywhere yet, so let's do that, and call our new function.
	Back in our initialize function, between our keyboard event handling code and our before-render handling code we can add:
	
	document.onkeyup = function(e) {
		// ... omitted for brevity ...
	}

  GameContext.alienMoveDirection = "RIGHT";
  setAliensMoving();
  
  GameContext.screen.on(C64Style.EventType.BEFORE_RENDER, function(e) {
    updateShip(e);
  });
  
  Now if we reload our game, we should see the aliens move to the right and shortly disappear of the right side of the screen.
  We need a way to check if any of our aliens are near the edge of the screen, and if so, make all the aliens move down a little bit.
  So let's create a function that checks the position of all the aliens and return whether or not any of them are touching a particular boundary:
  
  function anyAlienAtX(boundary) {
	  var result = false;
	  GameContext.aliens.forEach(function(alien) {
		if (alien.getX() <= boundary && alien.getX() + alien.getWidth() >= boundary) result = true;
	  });
	  return result;
	}
	If the boundary argument falls between any alien's x coordinate and the alien's right edge coordinate (x + width), then we return true.
	Now we need a place to call that, and to handle things when it returns true.  When it is true, we need to move the aliens down.  We'll make another function:
	
	function updateAliens(event) {
	  if (!GameContext.aliensMovingDown &&
		((anyAlienAtX(4) && GameContext.alienMoveDirection === "LEFT") || (anyAlienAtX(316) && GameContext.alienMoveDirection ==="RIGHT"))) {
		moveAliensDown();
	  }
	}
	Only a few lines, but there is a lot going on here.  You can see the boundary checks (anyAlienAtX(4) and anyAlienAtX(316)) are coupled with a check of our movement direction, 
	and with a check whether the aliens are moving down (we haven't defined this yet, but we will soon).
	The logic here is that we only want this to trigger if we are moving toward the right wall and hit our boundary, or moving toward the left wall and hit our boundary.  
	We don't want to trigger this if the aliens are moving away from the wall, or if they are moving down.  
	In the case that these conditions are true, we want to move our aliens down.  Here's a function for that:
	
	function moveAliensDown() {
	  GameContext.aliens.forEach(function(alien) {
		alien.moveTo(alien.getX(), alien.getY() + 16, 1100);
		alien.setMoveRates(0,0);
	  });
	  GameContext.aliensMovingDown = true;
	}
	
	This does a couple of things.  We give each alien a specific destination: its current x coordinate (no change) and an incremental amount over it's current y coordinate.  
	This move will run over the course of 1.1 seconds.  
	On the next line we are setting our movement rates to zero.  This may seem counter intuitive, but it is important to understand that movement rates and moveTo instructions
	are not mutually exclusive; however, movement as a result of moveTo instructions supercedes movement caused by move rates (basically, if you have both running, you will only see the 
	movement caused by moveTo, until it completes; then the move rates will take effect again).
	Once we've set our aliens moving down, we set the flag to indicate that they are moving down.
	Speaking of which it is probably a good idea to give that flag an initial value before the action starts.  Back in our init code, add this:
	
	  GameContext.aliensMovingDown = false;
	  GameContext.alienMoveDirection = "RIGHT";
	  setAliensMoving();
	
	So now we have the instruction to move aliens down when they are near the edges of the screen.  We need to make this check every render cycle.  We can add to our before-render event handler:
	
	  GameContext.screen.on(C64Style.EventType.BEFORE_RENDER, function(e) {
		updateShip(e);
		updateAliens(e);
	  });
  
	So that's great.  If you run this now, you will see your aliens move to the right edge of the screen, move down when they hit it, and then... just stop.
	So we need to send them back the other direction when all the aliens have completed their downward movement.
	We'll create a function to handle this:
	
	function alienStoppedMoving() {
	  GameContext.alienCounter++;
	  if (GameContext.alienCounter === GameContext.aliens.length)  {
		GameContext.aliensMovingDown = false;
		GameContext.alienCounter = 0;
		if (GameContext.alienMoveDirection === "RIGHT") {
		  GameContext.alienMoveDirection = "LEFT";
		} else {
		  GameContext.alienMoveDirection = "RIGHT";
		}
		setAliensMoving();
	  }
	}
	
	We'll be calling this each time that an alien stops moving, and we only want to set them moving again after all the aliens have stopped.  So we keep a counter,
	and when all aliens are accounted for, we take action.  They are no longer moving down, so we can set that flag false.  And we'll need to reset our counter.
	Then we check the last direction they were moving and switch it: if they were moving right, we send them left, and vice versa.  Once that's done, we call our setAliensMoving()
	function to get them moving again.
	
	Before we forget, we referenced an alienCounter variable that we hadn't yet defined.  Let's do that now, in the same place we initialize the other alien stuff:
	  GameContext.aliensMovingDown = false;
	  GameContext.alienMoveDirection = "RIGHT";
	  GameContext.alienCounter = 0;
	  setAliensMoving();
	  
	Now, we need to find a way to call this when the aliens stop moving.  We can actually add this directly to our moveTo function call:
	function moveAliensDown() {
	  GameContext.aliens.forEach(function(alien) {
		alien.moveTo(alien.getX(), alien.getY() + 16, 1100, alienStoppedMoving);
		alien.setMoveRates(0,0);
	  });
	  GameContext.aliensMovingDown = true;
	}
	  
	  Side note: Due to the way we are moving our ship (directly calculating and setting XY values), movement is not detected, so moving the ship will not trigger
	  ELEMENT_STARTED_MOVING or ELEMENT_STOPPED_MOVING events.  If we had chosen a different method of moving the ship, either through moveTo or setMoveRates, then 
	  if we attached our handler to the screen we would have to check if the element had stopped was an alien, or the ship.  Alternatively, we could have attached the handler to
	  each alien and not to the ship, then we could be sure that any time that function was called it was being called for an alien.
	  
	  Now we are really getting somewhere! Our ship moves in response to arrow keys, and our aliens creep steadily forward.  Let's add some bullets for our spaceship.
	  After we declare GameContext, add this line:
	  
	  GameContext.bulletPix = [{"type":"RECTANGLE", "x":0, "y":0, "width":2, "height": 6, "color":C64Style.Color.WHITE}];
	  
	  We can create an element for it in our init function, right after we create our ship:
	  
	  ...
	    GameContext.gfxLayer.addElement(GameContext.shipElement);

	  GameContext.bulletElement = new C64Style.PixElement(GameContext.screen, GameContext.gfxLayer, {
		hidden:true,
		pixPathArray: GameContext.bulletPix,
		defaultPalette: C64Style.Color.getDefaultPalette()
	  });
	  GameContext.gfxLayer.addElement(GameContext.bulletElement);
	  ...
	  
	  Notice that we set it hidden to start with.  We only want to display it when the ship fires it.  To make it fire, let's add an event handler for when the spacebar is pressed.
	  We can piggy back off our existing onkeydown handler:
	    document.onkeydown = function(e) {
    var preventDefault = false;
    switch (e.key) {
      case "ArrowLeft":
        GameContext.shipMovingLeft = true;
        break;
      case "ArrowRight":
        GameContext.shipMovingRight = true;
        break;
      case " ":
        fireBullet();
        break;
      default:
        break;
    }
    if (preventDefault) event.preventDefault();
    return !preventDefault;
  }
  
  And then create the referenced function:
  
  function fireBullet() {
	  GameContext.bulletElement.setX(GameContext.shipElement.getX() + 15);
	  GameContext.bulletElement.setY(154);
	  GameContext.bulletElement.show();
	  GameContext.bulletElement.setMoveRates(0, -120);
	}
	
	We need to remove the bullet if it hits the top edge of the screen.  We can just leave it wherever it is, but hide it and stop it's move rates:
	function removeBullet() {
	  GameContext.bulletElement.hide();
	  GameContext.bulletElement.setMoveRates(0, 0);
	}
	
	To call this, we can attach it to the ELEMENT_HIT_TOP_EDGE event on the bullet:
	  GameContext.bulletElement.on(C64Style.EventType.ELEMENT_HIT_TOP_EDGE, function(e) {
		removeBullet();
	  });
	  
	  
	  When the bullet hits one of the aliens, both the bullet and the alien need to be removed.  We can use the same function we created earlier for the bullet.
	  The function for the aliens needs to be a little bit different:
	  
	  function killAlien(alien) {
		  GameContext.gfxLayer.removeElement(alien);
		  var idx = C64Style.linSearch(GameContext.aliens, alien, function(element,value){return element.getId() === value.getId();});
		  GameContext.aliens.splice(idx,1);
		  removeBullet();
		}
		
	We remove the alien from the screen, and also remove it from our list of aliens in the game context.  
	To call the function, we can add a collision event handler back in the initialization function:
	
	 GGameContext.bulletElement.on(C64Style.EventType.ELEMENT_COLLISION, function(e) {
		if (e.data.element1.getId() === GameContext.bulletElement.getId()) {
		  killAlien(e.data.element2);
		} else if (e.data.element2.getId() === GameContext.bulletElement.getId()) {
		  killAlien(e.data.element1);
		}
	  });
	  
	  The collision event capture the elements involved and puts them in the event data.  When we attach our handler to the element, element1 in the event data will always be
	  the element we attached to, and element2 will always be the other element involved in the collision.
	  
	  Now when the bullet hits an alien, it disappears.  Let's add score functionality.  Let's create a variable to hold the score, either before or in our initialization code:
	  
	  GameContext.score = 0;
	  
	  To make things more interesting, let's give a different point value to the different colors of aliens.  We'll make the red ones worth 10 points and the blue ones worth 20.
	  We can add this directly to the alien elements, in our createAlien() function:
	  
	  function createAlien(x,y, palette, scoreValue) {
		  var newAlien = new C64Style.PixSprite(GameContext.screen, GameContext.gfxLayer, {
			frames:[GameContext.alienFrame1,GameContext.alienFrame2],
			x:x,
			y:y,
			defaultPalette: palette
		  });
		  newAlien.scoreValue = scoreValue;
		  return newAlien;
		}
	  
	  And update the initialization code appropriately:
	  
  var x = 8;
  for (var i = 0; i < 8; i++) {
    var newAlien = createAlien(x, 32, C64Style.Color.getDefaultPalette(), 20);
    GameContext.aliens.push(newAlien);
    GameContext.gfxLayer.addElement(newAlien);
    x += 20;
  }
...
  x = 8;
  for (var i = 0; i < 8; i++) {
    var newAlien = createAlien(x, 48, altPalette, 10);
    GameContext.aliens.push(newAlien);
    GameContext.gfxLayer.addElement(newAlien);
    x += 20;
  }
		 
		Ideally, it would probably be better to create a new type of graphics element if we intend to store additional information in it, but this keeps things simpler for the tutorial.
		Now we can add to our score when we kill an alien:
		function killAlien(alien) {
		  GameContext.score += alien.scoreValue;
		  GameContext.gfxLayer.removeElement(alien);
		  var idx = C64Style.linSearch(GameContext.aliens, alien, function(element,value){return element.getId() === value.getId();});
		  GameContext.aliens.splice(idx,1);
		  removeBullet();
		}
		
		We can add the score place holder just after we added our other text:
		  GameContext.textLayer = GameContext.screen.createLayer("TextLayer");
		  GameContext.textLayer.writeText("Alien Invasion!", 12,1, C64Style.Color.WHITE);
		  GameContext.textLayer.writeText("Score:", 1,24, C64Style.Color.WHITE);
		  
		Then create a function to write the score to the screen:
		
		function updateScore() {
		  GameContext.textLayer.writeText(GameContext.score, 8, 24, C64Style.Color.WHITE);
		}
		
		And then call that in our before-render handler:
		  GameContext.screen.on(C64Style.EventType.BEFORE_RENDER, function(e) {
			updateShip(e);
			updateAliens(e);
			updateScore();
		  });
		  
		We have a sort of playable game now. But let's make it more challenging - we can have the aliens shoot back.
		Add a new pixArray:
		GameContext.bulletPix = [{"type":"RECTANGLE", "x":0, "y":0, "width":2, "height": 6, "color":C64Style.Color.WHITE}];
		GameContext.alienBullet = [{"type":"PIXEL","x":0,"y":0,"color":2},{"type":"PIXEL","x":1,"y":0,"color":2},{"type":"PIXEL","x":0,"y":1,"color":2},{"type":"PIXEL","x":0,"y":2,"color":2},{"type":"PIXEL","x":1,"y":2,"color":2},{"type":"PIXEL","x":1,"y":3,"color":2},{"type":"PIXEL","x":0,"y":4,"color":2},{"type":"PIXEL","x":0,"y":5,"color":2},{"type":"PIXEL","x":1,"y":5,"color":2},{"type":"PIXEL","x":1,"y":6,"color":2}];
		
		Create a function to create an alien bullet:
		function createAlienBullet(x, y) {
		  var bullet = new C64Style.PixElement(GameContext.screen, GameContext.gfxLayer, {
			pixPathArray: GameContext.alienBulletPix,
			defaultPalette: C64Style.Color.getDefaultPalette(),
			x:x,
			y:y
		  });
		  return bullet;
		}
		
		The x and y obviously tell us where to put the bullet.  We need some logic to tell us when and which alien will shoot.  We create:
		function alienAttack() {
		  if (GameContext.aliens.length === 0) return;
		  var roll = Math.floor(Math.random() * 25);
		  if (roll === 0) {
			var alien = pickAlien();
			var bullet = createAlienBullet(alien.getX() + 8, alien.getY() + 16);
			GameContext.gfxLayer.addElement(bullet);
			bullet.setMoveRates(0,135);
		  }
		}
		
		First we check that there aliens remaining.  We pick a random number to determine if some alien should shoot (Here we pick a random number 0-24. a higher range means shoot less often, a lower range means shoot more often); 
		if our "roll" succeeds, we pick and alien, create our bullet, add it to the gfxLayer, and send it moving.
		To figure out which alien does the shooting, we use this function:

		function pickAlien() {
		  var alienIdx = Math.floor(Math.random() * GameContext.aliens.length);
		  return GameContext.aliens[alienIdx];
		}
		
		Pretty straight forward - we pick a random alien.
		
		Now we need to call the alien attack function. We can add this to our before-render handler.  Anywhere should do fine, I added it second to last:
		
		  GameContext.screen.on(C64Style.EventType.BEFORE_RENDER, function(e) {
			updateShip(e);
			updateAliens(e);
			alienAttack();
			updateScore();
		  });
		  
		  It's probably a good idea to cleanup bullets as they leave the bottom of the screen.
		  
		  	First let's get rid of the offending bullet:
	
			function removeAlienBullet(bullet) {
			  GameContext.gfxLayer.removeElement(bullet);
			}
				 
			This function is simple enough.  We pass in a bullet (a gfx element), and then we ask the gfxLayer to remove it.
		  
		  Then we can update alienAttack() to incorporate the functionality.
		  
		  function alienAttack() {
		  if (GameContext.aliens.length === 0) return;
		  var roll = Math.floor(Math.random() * 25);
		  if (roll === 0) {
			var alien = pickAlien();
			var bullet = createAlienBullet(alien.getX() + 8, alien.getY() + 16);
			GameContext.gfxLayer.addElement(bullet);
			bullet.setMoveRates(0,135);
			bullet.on(C64Style.EventType.ELEMENT_HIT_BOTTOM_EDGE, removeAlienBullet.bind(null, bullet));
		  }
		}
		  
		 The aliens fire bullets randomly now:
		 <IMG7>
		 
		 But there is no danger to the ship yet, we must add that!
		 I created an explosion animation for the ship: explosion.png.
		 
		 We'll need to load this much like we did the png for the ship.  but we now have two images that must load before we start the game, so we have to keep track
		 and only initialize our code when all images complete.  So I created a function to handle that:
		 
		 GameContext.shipPng = new Image();
			GameContext.shipPng.src = "ship.png";
			GameContext.shipPng.onload = function() {
			  checkImagesLoaded();
			}

			GameContext.explosionPng = new Image();
			GameContext.explosionPng.src = "explosion.png";
			GameContext.explosionPng.onload = function() {
			  checkImagesLoaded();
			}

			var imagesLoadedCount = 0;
			var imagesToLoad = 2;
			function checkImagesLoaded() {
			  imagesLoadedCount++;
			  if (imagesLoadedCount === imagesToLoad) {
				initialize(document.getElementById("content"), config);
			  }
			}
			
		You'll notice that instead of calling initialize directly from the onload method of the image, I now call checkImagesLoaded() instead, and then count to see if all have loaded.
		If so, then we call initialized. 
		If you are loading many images, it is probably a good idea to put together a class or package where you can just send in an array of image urls, and have it return an array of images when complete.
		
		So, now we've loaded our explosion png, we need to make an animated sprite out of it.  We can add this code after our bullet element creation code:
		
		  GameContext.bulletElement = new C64Style.PixElement(GameContext.screen, GameContext.gfxLayer, {
    hidden:true,
    pixPathArray: GameContext.bulletPix,
    defaultPalette: C64Style.Color.getDefaultPalette()
  });
  GameContext.gfxLayer.addElement(GameContext.bulletElement);

  GameContext.explosionElement = new C64Style.ImageSprite(GameContext.screen, GameContext.gfxLayer, {
    hidden:true,
    width:32,
    height:32,
    image:GameContext.explosionPng,
    frames:[
      new C64Style.ImageSpriteFrame({duration:50, sourceX:0, sourceY:0, sourceWidth:32, sourceHeight:32}),
      new C64Style.ImageSpriteFrame({duration:50, sourceX:32, sourceY:0, sourceWidth:32, sourceHeight:32})
    ]
  });
  GameContext.gfxLayer.addElement(GameContext.explosionElement);
  
  Notice that creating an image sprite is a little different than creating a PixSprite.  We pass our loaded image in as the value of the "image" properties.  We set the desired width
  and height.  If the image (or image region) we are drawing doesn't fit those dimensions it will be stretched or shrunk appropriately.  We still need
  frames since it is a sprite, but we construct the frames a little differently.  Instead of specifying different PixArrays, we specify regions of the image.  If you 
  open the png in an image viewer, you will notice that there are two explosions side by side, with some small differences between them.  By only drawing a portion of the image,
  and flashing between the two regions, we can create an animation effect.  That is what we are doing here.  The first frame specifies the region for the left most explosion, 
  the second for the right most explosion.    
  
  As before, since we aren't using it right away, we can just hide it.  
		 
	We've got a little more work to do before we bring this explosion into play.
	When the ship is hit several things need to happen - we need to remove the alien bullet that collided with the ship, hide the ship, move the explosion to the ships location 
	and show the explosion.  There's a few more things we need to do to add some polish, but let's take things one step at a time.
	

	The fun part: let's blow up our ship!
	
	function blowUpShip() {
	  GameContext.shipElement.hide();
	  GameContext.explosionElement.setX(GameContext.shipElement.getX());
	  GameContext.explosionElement.setY(GameContext.shipElement.getY());
	  GameContext.explosionElement.show();
	}
	
	No real surprises here.  We hide the ship, move the explosion sprite to the ships location, and then show the explosion.
	That could be the end of the game, but that's not much fun.  Most of these type of games give you several chances, "lives", or in our case, ships.
	We need to display the explosion long enough for the player to realize what happened, then restore the ship and normal gameplay.
	It would also be nice if we paused the action while we show the explosion - stop the aliens moving or firing, and let any current alien bullets pass.  This
	will make the player happier.
	
	We'll create two functions to handle this, pauseAction and unpauseAction:
	function pauseAction() {
	  GameContext.actionPaused = true;
	  GameContext.shipMovingLeft = false;
	  GameContext.shipMovingRight = false;
	  GameContext.aliens.forEach(function(alien) {
		alien.setMoveRates(0,0);
	  });
	}

	function unpauseAction() {
	  GameContext.actionPaused = false;
	  GameContext.shipElement.show();
	  GameContext.explosionElement.hide();
	  setAliensMoving();
	}
	
	In each of these function we flip a flag called actionPaused.  This doesn't do anything inherently it will be used elswhere.  Before we get to that, let's look at what else is happening here.
	in pauseAction, we set the ship moving variables to false - to cancel any current movement.  We also set the move rates for all the aliens to zero.  
	There is the possibility that the aliens will be moving downward (via moveTo) at the time this function is called.  At present, there's not a way to stop or cancel a running
	moveTo instruction.  However, in this case, I don't think it is a big deal - the amount of movement is relatively small, and it shouldn't hurt anything to let the aliens
	finish this move even if everything else is paused.
	
	In unpauseAction, we restore the ship (show()) and hide the explosion.  Then we set the aliens moving again.
	
	Oh, and don't forget to initialize that actionPaused flag somewhere - I do it after score:
		GameContext.score = 0;
		GameContext.actionPaused = false;
		
	To call these functions, let's revisit our blowUpShip function:
	
		function blowUpShip() {
		  GameContext.shipElement.hide();
		  GameContext.explosionElement.setX(GameContext.shipElement.getX());
		  GameContext.explosionElement.setY(GameContext.shipElement.getY());
		  GameContext.explosionElement.show();
		    pauseAction();
			setTimeout(unpauseAction, 1000);
		}
	
		Now when the ship gets blown up, we pause the action, and set a 1 second timer to call unpause.
		So we've set this up, but right now we still have other events and things that can trigger, even though we have stopped the action, so we need to address those.
		First, let's stop key down/up events from doing anything
		
		  document.onkeydown = function(e) {
		if(GameContext.actionPaused) return true;
		var preventDefault = false;
		switch (e.key) {
		  case "ArrowLeft":
			GameContext.shipMovingLeft = true;
			break;
		  case "ArrowRight":
			GameContext.shipMovingRight = true;
			break;
		  case " ":
			fireBullet();
			break;
		  default:
			break;
		}
		if (preventDefault) event.preventDefault();
		return !preventDefault;
	  }
	  document.onkeyup = function(e) {
		if(GameContext.actionPaused) return true;
		var preventDefault = false;
		switch (e.key) {
		  case "ArrowLeft":
			GameContext.shipMovingLeft = false;
			break;
		  case "ArrowRight":
			GameContext.shipMovingRight = false;
			break;
		  default:
			break;
		}
		if (preventDefault) event.preventDefault();
		return !preventDefault;
	  }
	  
	  So now, the player can't fire bullets, or cause direction movement for the ship.
	  In before render, we need to stop the normal actions:
	  GameContext.screen.on(C64Style.EventType.BEFORE_RENDER, function(e) {
		if (GameContext.actionPaused) return;
		updateShip(e);
		updateAliens(e);
		alienAttack();
		updateScore();
	  });
	  
	  And we need to update our alienStoppedMoving handler:
	  function alienStoppedMoving(element) {
		  GameContext.alienCounter++;
		  if (GameContext.alienCounter === GameContext.aliens.length)  {
			GameContext.aliensMovingDown = false;
			GameContext.alienCounter = 0;
			if (GameContext.alienMoveDirection === "RIGHT") {
			  GameContext.alienMoveDirection = "LEFT";
			} else {
			  GameContext.alienMoveDirection = "RIGHT";
			}
			if (!GameContext.actionPaused) setAliensMoving();
		  }
		}
		
		This way, If the were in the middle of the downard moveTo instruction, they won't automatically start moving again - they will have to wait for the unpause function to
		start them moving again.
	
		Now we need to tie this all together.  We need to trigger these functions when something collides with our ship, say an alien bullet, or an alien.  Back in our initialize
		code we can add another collision handler:
		  GameContext.shipElement.on(C64Style.EventType.ELEMENT_COLLISION, function(e) {
			if (e.data.element2.isAlien) {
			  killAlien(e.data.element2);
			} else {
			  // assume it is a bullet. be careful if there are other types of elements that the ship can collide with!
			  removeAlienBullet(e.data.element2);
			}
			blowUpShip();
		  });
	
		First we determine if what hit the ship was an alien or an alien bullet, and handle appropriately.  Then, we blow up the ship.
		
		<IMG_EXPLOSION>
		
		Now you can play the game, and if your ship gets hit, it blows up, and restores itself a second later.  This is fine, but you have unlimited chances this way.  
		Let's change that.
		Let's define a variable that limits how many ships we have remaining:
		
		GameContext.score = 0;
		GameContext.actionPaused = false;
		GameContext.shipsRemaining = 2;
		
		And then let's use it for something:
		
		function blowUpShip() {
		  GameContext.shipElement.hide();
		  GameContext.explosionElement.setX(GameContext.shipElement.getX());
		  GameContext.explosionElement.setY(GameContext.shipElement.getY());
		  GameContext.explosionElement.show();
		  GameContext.shipsRemaining--;
		  pauseAction();
		  if (GameContext.shipsRemaining <  0) {
			endGame(false);
		  } else {
			setTimeout(unpauseAction, 1000);
		  }
		}
		
		So now, if the ship is blown up, we decrement the number of ships remaining and check if it is less than zero.  If so we "end" the game.  Otherwise, 
		we continue as before.
		So what about this end of the game?
		
		function endGame(victory) {
		  var msg, color, bgColor;
		  if (victory) {
			msg = "VICTORY!";
			color = C64Style.Color.CYAN;
			bgColor = C64Style.Color.BLUE;
		  } else {
			msg = "FAILURE!";
			GameContext.explosionElement.hide();
			color = C64Style.Color.ORANGE;
			bgColor = C64Style.Color.RED;
		  }
		  var scaleX = 3;
		  var scaleY = 3;
		  var x = ((C64Style.CELLWIDTH * config.cols) - (msg.length * C64Style.CELLWIDTH * scaleX)) / 2;
		  var msgElement = new C64Style.TextElement(GameContext.screen, GameContext.gfxLayer, {
			text:msg,
			color:color,
			backgroundColor:bgColor,
			scaleX:scaleX,
			scaleY:scaleY,
			y:50,
			x:x
		  });
		  GameContext.gfxLayer.addElement(msgElement);
		}
		
		This is a large function, but it really doesn't do that much.  We accept a boolean "victory" variable to tell us if we won or lost.  We'll deal with win conditions a 
		bit later.  For now, let's worry about what happens when we've lost.
		We define a message ("msg") and some colors, hide the explosion, and then create a text element with the properties we specified (message, colors).  The purpose
		of the calculations of the "x" variable are to center the message on the screen.
		This is really it.
		
		That's great, but we also need a way to tell the player how many ships they have left.
		We'll start by writing some placeholder text to the screen, in the same way we did for the score:
		  GameContext.textLayer = GameContext.screen.createLayer("TextLayer");
		  GameContext.textLayer.writeText("Alien Invasion!", 12,1, C64Style.Color.WHITE);
		  GameContext.textLayer.writeText("Score:", 1, 24, C64Style.Color.WHITE);
		  GameContext.textLayer.writeText("Ships Remaining:", 22, 24, C64Style.Color.WHITE);
		
		Then we'll add a function to write the remaining number to screen:
		function updateShipsRemaining() {
		  GameContext.textLayer.writeText(GameContext.shipsRemaining, 39, 24, C64Style.Color.WHITE);
		}
		
		Simple enough.
		We can call this method in our before render handler:
		
		  GameContext.screen.on(C64Style.EventType.BEFORE_RENDER, function(e) {
			if (GameContext.actionPaused) return;
			updateShip(e);
			updateAliens(e);
			alienAttack();
			updateScore();
			updateShipsRemaining();
		  });
		
		Now, we can see how many ships are left.
		
		To polish things off, let's add a victory condition.  If all the aliens are dead, we win!
		
		function checkVictoryCondition() {
		  if (GameContext.aliens.length === 0) {
			pauseAction();
			endGame(true);
		  }
		}
		
		Note that we pause the action before ending the game.  This will be the same state we were in (action paused) when we check how many ships we have left.
		Basically, there's nothing left to do when the game is over, so we always arrive at end game from an action-paused state.
		Here, we send 'true' to our end game function, so we will see the victory message instead.
		


