<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Common/PriorityQueue.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Common/PriorityQueue.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** IComparable
* @interface
*/
function IComparable() {}
/**
* @function
* @name IComparable#compareTo
* @param other {Object} The object to compare to this one.
* @returns {int} -1: less than the other object; 0 equivalent to the other object; 1 greater than the other object.
*/
IComparable.prototype.compareTo = function(other) { throw new Error('not implemented'); };
/**
* @function
* @name IComparable#equals
* @param other {Object} The object to compare to this one.
* @returns {boolean} true if the objects are equivalent, false otherwise.
*/
IComparable.prototype.equals = function(other) { throw new Error('not implemented'); };


/** @class Heap-based priority queue */
function PriorityQueue() {

  this._heapSize = 0;
  this._a = [];
  /** True: largest values will be at the front of the queue.
  * False: smallest values will be at the front of the queue.
  * False by default.
  */
  this.invertPriority = false;
}

/** Set whether this queue has inverted priority or not.
* False: smallest values will be at the front of the queue.
* True: largest values will be at the front of the queue.
* False by default.
* Setting the value will cause the queue to be reordered.
* @param bool {boolean}
*/
PriorityQueue.prototype.setInvertPriority = function(bool) {
  this.invertPriority = bool;
  this.sort();
};

/** Sorts the queue.  */
PriorityQueue.prototype.sort = function() {

  this._buildMaxHeap();

  for (var i = this._heapSize - 1; i >= 1; i--) {
    this._swap(0,i);
    this._maxHeapify(0, (this._heapSize - (this._heapSize-i)) );
  }
};

/** @private */
PriorityQueue.prototype._maxHeapify = function( i, size, dir ) {
  var largest = 0;
  var left = 2 * i + 1;
  var right = 2 * i + 2;
  if (dir === undefined) dir = this.invertPriority ? -1 : 1;

  if ( left &lt; size &amp;&amp; this._a[left].compareTo(this._a[i]) === dir ) {
    largest = left;
  } else {
    largest = i;
  }

  if ( right &lt; size &amp;&amp; this._a[right].compareTo(this._a[largest]) === dir ) {
    largest = right;
  }

  if ( largest != i ) {
    this._swap(i,largest);
    this._maxHeapify( largest, size, dir );
  }
};

/** @private */
PriorityQueue.prototype._swap = function(i1,i2) {
  var temp = this._a[i1];
  this._a[i1] = this._a[i2];
  this._a[i2] = temp;
};

/** @private */
PriorityQueue.prototype._buildMaxHeap = function() {
  for (var i = Math.floor((this._heapSize - 1) / 2); i >= 0; i--) {
    this._maxHeapify( i, this._heapSize );
  }
};

/** Removes and returns the item at the front of the queue
* @return {Object} The item at the front of the queue.
*/
PriorityQueue.prototype.extractMax = function() {
  if ( this._heapSize &lt; 1 ) {
    return null;
  }

  var max = this._a[0];
  this._a[0] = this._a[this._heapSize-1];
  this._heapSize--;
  this._maxHeapify( 0, this._heapSize,  this.invertPriority ? 1 : -1);
  return max;
};

/** Adds a new item to the queue.
* @param element {IComparable} The item to be added to the queue.  Must implement Comparable.
*/
PriorityQueue.prototype.insert = function( element ) {
  var i = this._heapSize;

  if (this._heapSize === this._a.length)
    this._a.push(element);
  else
    this._a[i] = element;
  this._heapSize++;

  this.increaseKey(i);
};

/** Used to update the queue when a element's priority has been increased.
* Assumes the element has already been inserted.
* Assumes you have updated the value on your own.
* @param i {int} The index of the element to be updated.
*/
PriorityQueue.prototype.increaseKey = function(i) {
  while (i > 0 &amp;&amp; this._a[this._parent(i)].compareTo(this._a[i]) === (this.invertPriority ? -1 : 1)) {
    this._swap(i,this._parent(i));
    i = this._parent(i);
  }
};

/** Used to update the queue when a element's priority has been decreased.
* Assumes the element has already been inserted.
* Assumes you have updated the value on your own.
* @param i {int} The index of the element to be updated.
*/
PriorityQueue.prototype.decreaseKey = function(i) {
  this._maxHeapify(i, this._heapSize, this.invertPriority ? 1 : -1);
};

/** Retrieve the element at a specified index.
* Throws an error if i is out of bounds.
* @param i {int} The index of the target element
* @return {Object} The element found at the specified index.
*/
PriorityQueue.prototype.getByIndex = function(i) {
  if (i > this._heapSize || i &lt; 0)
    throw new Error("Index out of bounds: " + i + ". (queue size:" + this._heapSize + ")");
  return this._a[i];
};

/** Retrieve the first element that equals one specified.
* Use this if you need to update the value/priority of an element in the queue.
* @param i {IComparable} An element to search for.
* @return {Object} The element if found; null otherwise.
*/
PriorityQueue.prototype.getByEquality = function(element) {
  var idx = this.indexOf(element);
  if (idx === -1) return null;
  return this._a[idx];
};

/** Returns the size of the queue
* @return {int} The size of the queue.
*/
PriorityQueue.prototype.size = function() {
  return this._heapSize;
};

/** Returns whether the item exists in the queue.
* @param element {IComparable} The element to search for.
* @return {boolean} True if the element is in the queue; false otherwise.
*/
PriorityQueue.prototype.contains = function(element) {
  for (var i = 0; i &lt; this._heapSize; i++) {
    if (element.equals(this._a[i])) return true;
  }
  return false;
};

/** Returns the index of the item if it exists in the queue.
* @param element {IComparable} The element to search for.
* @return {int} The index of the element in the queue; -1 if it does not exist.
*/
PriorityQueue.prototype.indexOf = function(element) {
  for (var i = 0; i &lt; this._heapSize; i++) {
    if (element.equals(this._a[i])) return i;
  }
  return -1;
};

/**
* @param element {Object} The element to be removed from the list.
*/
PriorityQueue.prototype.remove = function(element) {
  if ( this._heapSize &lt; 1 ) {
    return;
  }

  var idx = this.indexOf(element);
  if (idx &lt; 0) return;

  this._a[idx] = this._a[this._heapSize-1];
  this._heapSize--;
  this._maxHeapify( idx, this._heapSize,  this.invertPriority ? 1 : -1);
};

/** Clear the queue. */
PriorityQueue.prototype.clear = function() {this._heapSize = 0;};

/** @private */
PriorityQueue.prototype._verifyHeap = function(i) {
  if (i === undefined || i === null) i = 0;
  if (i >= this._heapSize) return true;
  var dir = this.invertPriority ? 1 : -1;
  var left = 2 * i + 1;
  var right = 2 * i + 2;
  var isok = true;

  if (left &lt; this._heapSize &amp;&amp; this._a[left].compareTo(this._a[i]) === dir) isok = false;
  if (isok &amp;&amp; right &lt; this._heapSize &amp;&amp; this._a[right].compareTo(this._a[i]) === dir) isok = false;

  if (isok &amp;&amp; left &lt; this._heapSize) {
    isok = this._verifyHeap(left);
    if (isok &amp;&amp; right &lt; this._heapSize) {
      isok = this._verifyHeap(right);
    }
  }
  return isok;
};

/** @private */
PriorityQueue.prototype._parent = function(i) { return Math.floor((i - 1) / 2); };

/** Removes and returns the item at the front of the queue
* @method
* @return {Object} The item at the front of the queue.
*/
PriorityQueue.prototype.pop = PriorityQueue.prototype.extractMax;

/** Removes and returns the item at the front of the queue
* @method
* @return {Object} The item at the front of the queue.
*/
PriorityQueue.prototype.poll = PriorityQueue.prototype.extractMax;

/** Adds a new item to the queue.
* @method
* @param element {IComparable} The item to be added to the queue.  Must implement Comparable.
*/
PriorityQueue.prototype.push = PriorityQueue.prototype.insert;

/** Retrieve the element at the front of the queue.
* @return {Object} The element at the front of the queue.
*/
PriorityQueue.prototype.peek = function() {return this._heapSize &lt; 1 ? null : this._a[0];};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="C64Style.CharacterRenderer.html">CharacterRenderer</a></li><li><a href="C64Style.ColorPointer.html">ColorPointer</a></li><li><a href="C64Style.Event.html">Event</a></li><li><a href="C64Style.GfxElement.html">GfxElement</a></li><li><a href="C64Style.GfxElementZIndexComparable.html">GfxElementZIndexComparable</a></li><li><a href="C64Style.GfxLayer.html">GfxLayer</a></li><li><a href="C64Style.ImageElement.html">ImageElement</a></li><li><a href="C64Style.ImageRenderer.html">ImageRenderer</a></li><li><a href="C64Style.ImageSprite.html">ImageSprite</a></li><li><a href="C64Style.ImageSpriteFrame.html">ImageSpriteFrame</a></li><li><a href="C64Style.Layer.html">Layer</a></li><li><a href="C64Style.MoveOrder.html">MoveOrder</a></li><li><a href="C64Style.PixElement.html">PixElement</a></li><li><a href="C64Style.PixRenderer.html">PixRenderer</a></li><li><a href="C64Style.PixSprite.html">PixSprite</a></li><li><a href="C64Style.PixSpriteFrame.html">PixSpriteFrame</a></li><li><a href="C64Style.Queue.html">Queue</a></li><li><a href="C64Style.QueueElement.html">QueueElement</a></li><li><a href="C64Style.QueueIterator.html">QueueIterator</a></li><li><a href="C64Style.C64Screen.html">Screen</a></li><li><a href="C64Style.Sprite.html">Sprite</a></li><li><a href="C64Style.TextButton.html">TextButton</a></li><li><a href="C64Style.TextElement.html">TextElement</a></li><li><a href="C64Style.TextLayer.html">TextLayer</a></li><li><a href="C64Style.TextLink.html">TextLink</a></li><li><a href="C64Style.TextPrompt.html">TextPrompt</a></li><li><a href="PriorityQueue.html">PriorityQueue</a></li><li><a href="UniquePriorityQueue.html">UniquePriorityQueue</a></li></ul><h3>Namespaces</h3><ul><li><a href="C64Style.html">C64Style</a></li></ul><h3>Interfaces</h3><ul><li><a href="AnimationFrame.html">AnimationFrame</a></li><li><a href="IComparable.html">IComparable</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sat Jan 07 2017 22:46:22 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
