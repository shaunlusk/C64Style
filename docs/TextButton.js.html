<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: TextButton.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: TextButton.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {CELLHEIGHT,CELLWIDTH} from './Constants';
import {Color} from './Color';
import TextLink from './TextLink';

/** Provides a clickable button link.&lt;br />
* &lt;b>Extends&lt;/b>: {@link TextLink}
* @constructor
* @param {C64Screen} screenContext The target screen.
* @param {GfxLayer} parentLayer The parent layer that will draw this element.
* @param {Object} props Properties for this TextLink.  Supports:
* From {@link GfxElement}
*   &lt;ul>
*     &lt;li>scaleX - integer - Horizontal scale of this element.  Independent of screen scale.&lt;/li>
*     &lt;li>scaleY - integer - Vertical scale of this element.  Independent of screen scale.&lt;/li>
*     &lt;li>hidden - boolean - Whether to hide this element.&lt;/li>
*     &lt;li>x - number - The X coordinate for this element.&lt;/li>
*     &lt;li>y - number - The Y coordinate for this element.&lt;/li>
*     &lt;li>zIndex - number - The z-index; elements with higher zIndex values will be drawn later than those with lower values (drawn on top of those with lower values).&lt;/li>
*   &lt;/ul>
* From {@link TextElement}:
* &lt;ul>
*   &lt;li>text - string - The text for this element. A text string or a symbol name is required for TextElement.&lt;/li>
*   &lt;li>symbolName - string - The symbolName for this element.  A text string or a symbol name is required for TextElement.  Refer to symbol names in {@link CharacterMap}.&lt;/li>
*   &lt;li>color - Color - The color for the text. Default: Color.LIGHTBLUE&lt;/li>
*   &lt;li>backgroundColor - Color - The backgroundColor for the text. Default: no background color&lt;/li>
*   &lt;li>characterRenderer - CharacterRenderer - The renderer to use to draw text.
*     This can be shared with a renderer for drawing text elements.  If a renderer is not provided,
*     This TextLayer will create a {@link CharacterRenderer}.&lt;/li>
* &lt;/ul>
* From TextLink:
* &lt;ul>
*   &lt;li>mouseOverColor - Color - IGNORED FOR TEXTBUTTON&lt;/li>
*   &lt;li>mouseOverBackgroundColor - Color - IGNORED FOR TEXTBUTTON&lt;/li>
*   &lt;li>onClick - function - An optional function to call when the link is clicked.&lt;/li>
*   &lt;li>href - string - The location to navigate to when the link is clicked.&lt;/li>
*   &lt;li>newWindow - boolean - Whether to open the new location in a new window or not.&lt;/li>
* &lt;/ul>
* For TextButton:
* &lt;ul>
*   &lt;li>highlightButtonColor - Color - The color to draw the button border and to highlight the button with when the mouse is over.&lt;/li>
*   &lt;li>highlightTextColor - Color - The color to draw the button text.&lt;/li>
* &lt;/ul>
*/
function TextButton(props) {
  props = props || {};
  TextLink.call(this, props);

  this._buttonColor = props.buttonColor || this.getColor();
  this._textColor = props.textColor || this.getColor();

  this._highlightButtonColor = props.highlightButtonColor || this.getColor();
  this._highlightTextColor = props.highlightTextColor || this.getBackgroundColor();

  this._height = CELLHEIGHT * 3;
};

TextButton.prototype = new TextLink(null, null, {characterRenderer:{}});
TextButton.prototype.constructor = TextButton;

/** @private  */
TextButton.prototype._setWidth = function() {
  this._lastWidth = this._width;
  this._width = CELLWIDTH * ((this._text ? this._text.length : 1) + 2);
};

/** Render this element.
* @param {number} time The current time, in milliseconds.
* @param {number} diff The difference between the previous time and the current time, in milliseconds.
* @override
*/
TextButton.prototype.render = function(time,diff) {
  if (!this.isHidden() &amp;&amp; this.isDirty()) {
    this.drawTextButton();
  }
};

/** @private */
TextButton.prototype.drawTextButton = function() {
  var x = this.getX() * this.getScreenScaleX();
  var y = this.getY() * this.getScreenScaleY();
  var scaledCellWidth = CELLWIDTH * this.getTotalScaleX();
  var scaledCellHeight = CELLHEIGHT * this.getTotalScaleY();
  var edgeX = x + scaledCellWidth;
  var rightEdge = x + (this.getLength() * scaledCellWidth) + scaledCellWidth;
  var characterRenderer = this.getCharacterRenderer();
  var canvas = this.getCanvasContextWrapper();

  if (this._mouseIsOver) {
    for ( ; edgeX &lt; rightEdge; edgeX += scaledCellWidth) {
      characterRenderer.renderSymbol(canvas, "BAR_120", edgeX, y,  this.getBackgroundColor(), this._highlightButtonColor, this.getTotalScaleX(),this.getTotalScaleY());
      characterRenderer.renderSymbol(canvas, "BAR_121", edgeX, y + 2 * scaledCellHeight, this.getBackgroundColor(), this._highlightButtonColor, this.getTotalScaleX(),this.getTotalScaleY());
    }
    characterRenderer.renderSymbol(canvas, "PIPE_117", x, y + scaledCellHeight, this.getBackgroundColor(), this._highlightButtonColor, this.getTotalScaleX(),this.getTotalScaleY());
    characterRenderer.renderSymbol(canvas, "PIPE_118", rightEdge, y + scaledCellHeight, this.getBackgroundColor(), this._highlightButtonColor, this.getTotalScaleX(),this.getTotalScaleY());

    characterRenderer.renderSymbol(canvas, "ROUNDED_CORNER_FILLED_TOP_LEFT", x, y, this._highlightButtonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    characterRenderer.renderSymbol(canvas, "ROUNDED_CORNER_FILLED_TOP_RIGHT", rightEdge, y, this._highlightButtonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    characterRenderer.renderSymbol(canvas, "ROUNDED_CORNER_FILLED_BOTTOM_LEFT", x, y + 2 * scaledCellHeight, this._highlightButtonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    characterRenderer.renderSymbol(canvas, "ROUNDED_CORNER_FILLED_BOTTOM_RIGHT", rightEdge, y + 2 * scaledCellHeight, this._highlightButtonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());

    if (this.getText()) {
      characterRenderer.renderString(canvas, this.getText(), this.getTextX(), this.getTextY(), this._highlightTextColor, this._highlightButtonColor, this.getTotalScaleX(),this.getTotalScaleY());
    } else {
     characterRenderer.renderSymbol(canvas, this.getSymbolName(), this.getTextX(), this.getTextY(), this._highlightTextColor, this._highlightButtonColor, this.getTotalScaleX(),this.getTotalScaleY());
    }
  } else {
    for ( ; edgeX &lt; rightEdge; edgeX += scaledCellWidth) {
      characterRenderer.renderSymbol(canvas, "BAR", edgeX, y, this._buttonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
      characterRenderer.renderSymbol(canvas, "BAR", edgeX, y + 2 * scaledCellHeight, this._buttonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    }
    characterRenderer.renderSymbol(canvas, "|", x, y + scaledCellHeight, this._buttonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    characterRenderer.renderSymbol(canvas, "|", rightEdge, y + scaledCellHeight, this._buttonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());

    characterRenderer.renderSymbol(canvas, "ROUNDED_CORNER_TOP_LEFT", x, y, this._buttonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    characterRenderer.renderSymbol(canvas, "ROUNDED_CORNER_TOP_RIGHT", rightEdge, y, this._buttonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    characterRenderer.renderSymbol(canvas, "ROUNDED_CORNER_BOTTOM_LEFT", x, y + 2 * scaledCellHeight, this._buttonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    characterRenderer.renderSymbol(canvas, "ROUNDED_CORNER_BOTTOM_RIGHT", rightEdge, y + 2 * scaledCellHeight, this._buttonColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());

    if (this.getText()) {
      characterRenderer.renderString(canvas, this.getText(), this.getTextX(), this.getTextY(), this._textColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    } else {
      characterRenderer.renderSymbol(canvas, this.getSymbolName(), this.getTextX(), this.getTextY(), this._textColor, this.getBackgroundColor(), this.getTotalScaleX(),this.getTotalScaleY());
    }
  }

};

/** @private  */
TextButton.prototype.getTextX = function() {
  return this.getX() * this.getScreenScaleX() + CELLWIDTH * this.getTotalScaleX();
};

/** @private  */
TextButton.prototype.getTextY = function() {
  return this.getY() * this.getScreenScaleY() + CELLHEIGHT * this.getTotalScaleY();
};

export default TextButton;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="C64Screen.html">C64Screen</a></li><li><a href="CharacterRenderer.html">CharacterRenderer</a></li><li><a href="ColorPointer.html">ColorPointer</a></li><li><a href="PixElement.html">PixElement</a></li><li><a href="PixRenderer.html">PixRenderer</a></li><li><a href="PixSprite.html">PixSprite</a></li><li><a href="PixSpriteFrame.html">PixSpriteFrame</a></li><li><a href="TextButton.html">TextButton</a></li><li><a href="TextElement.html">TextElement</a></li><li><a href="TextLayer.html">TextLayer</a></li><li><a href="TextLink.html">TextLink</a></li><li><a href="TextPrompt.html">TextPrompt</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CELLHEIGHT">CELLHEIGHT</a></li><li><a href="global.html#CELLWIDTH">CELLWIDTH</a></li><li><a href="global.html#CharacterMap">CharacterMap</a></li><li><a href="global.html#Color">Color</a></li><li><a href="global.html#PixPathTypes">PixPathTypes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.2</a> on Fri Jul 26 2019 21:19:12 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
